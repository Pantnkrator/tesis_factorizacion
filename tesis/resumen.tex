\clearpage
% \doublespacing
\chapter*{\centering \normalsize RESUMEN}
El teorema fundamental de la aritmética establece que todo número puede expresarse como un producto de números primos o ser un número primo. En matemáticas y, más recientemente, en ciencias de la computación, un problema de gran importancia es encontrar el conjunto de números primos que, al multiplicarse, nos den el número original. Esta propiedad fundamental no solo es interesante desde un punto de vista teórico, sino que también tiene aplicaciones prácticas significativas en diversas áreas de la ciencia y la tecnología.

Aunque desde la antigüedad se conocen algoritmos para realizar esta tarea, hoy en día cobra una relevancia particular debido a que gran parte de la seguridad informática se basa en la dificultad de factorizar números muy grandes. A pesar de que existen algoritmos eficientes y con complejidades polinomiales para esta tarea, el enorme tamaño de los números utilizados en la criptografía moderna hace que la factorización siga siendo un desafío considerable. Esta dificultad es precisamente la que garantiza la seguridad de muchos sistemas criptográficos, como RSA, que dependen de la factorización de números compuestos muy grandes.

En esta tesis se realizará un análisis y comparación de varios algoritmos y métodos de factorización para determinar cuáles son los más adecuados según el tipo de número y el contexto en el que se deben usar. Además, se abordará el refinamiento de estos métodos durante su implementación en un lenguaje de programación moderno. Se considerarán varios enfoques, desde los más clásicos como el método de la división por prueba hasta los más avanzados como el algoritmo de factorización de Lenstra basado en curvas elípticas y el método general de números.

La elección del algoritmo adecuado no solo depende del tamaño del número a factorizar, sino también de otros factores como la disponibilidad de recursos computacionales y el tiempo disponible para el proceso de factorización. Por ejemplo, para números relativamente pequeños, los métodos clásicos pueden ser suficientemente rápidos y eficientes. Sin embargo, para números extremadamente grandes, se requieren métodos más avanzados y sofisticados que aprovechen propiedades matemáticas más profundas y que puedan ser paralelizados en sistemas de computación distribuida.

Además de la comparación de algoritmos, esta tesis también explorará la implementación práctica de estos métodos. Se evaluará el rendimiento en un lenguaje de programación moderno. Se realizarán experimentos para medir el tiempo de ejecución y la eficiencia de los algoritmos implementados en Python.

% El teorema fundamental de la aritmética establece que todo número puede expresarse como un producto de números primos o ser un número primo. En matemáticas y, más recientemente, en ciencias de la computación, un problema de gran importancia es encontrar el conjunto de números primos que, al multiplicarse, nos den el número original.

% Aunque desde la antigüedad se conocen algoritmos para realizar esta tarea, hoy en día cobra una relevancia particular debido a que gran parte de la seguridad informática se basa en la dificultad de factorizar números muy grandes. A pesar de que existen algoritmos eficientes y con complejidades polinomiales para esta tarea, el enorme tamaño de los números utilizados en la criptografía moderna hace que la factorización siga siendo un desafío considerable.

% En esta tesis se realizará un análisis y comparación de varios algoritmos y métodos de factorización para determinar cuáles son los más adecuados según el tipo de número y el contexto en el que se deben usar. Además, se abordará el refinamiento de estos métodos durante su implementación en un lenguaje de programación moderno.\\
\textbf{Palabras clave:} Factorización, números primos, teorema fundamental de la aritmética, factores primos.\\
\textbf{Metodología:} Método lógico inductivo.

\clearpage
\chapter*{\centering \normalsize ABSTRACT}
The fundamental theorem of arithmetic states that every number can be expressed as a product of prime numbers or be a prime number. In mathematics and, more recently, in computer science, a problem of great importance is finding the set of prime numbers that, when multiplied, give us the original number. This fundamental property is not only interesting from a theoretical point of view, but also has significant practical applications in various areas of science and technology.

Although algorithms for this task have been known since ancient times, it is particularly relevant today because much of computer security is based on the difficulty of factoring very large numbers. Although efficient algorithms with polynomial complexity exist for this task, the enormous size of the numbers used in modern cryptography means that factorization remains a considerable challenge. This difficulty is precisely what guarantees the security of many cryptographic systems, such as RSA, which depend on the factorization of very large composite numbers.

This thesis will analyze and compare several factorization algorithms and methods to determine which ones are the most suitable for the type of number and the context in which they are to be used. In addition, the refinement of these methods during their implementation in a modern programming language will be addressed. Several approaches will be considered, from the most classical ones such as the trial division method to the most advanced ones such as the Lenstra factorization algorithm based on elliptic curves and the general number method.

The choice of the appropriate algorithm not only depends on the size of the number to be factored, but also on other factors such as the availability of computational resources and the time available for the factorization process. For example, for relatively small numbers, classical methods can be sufficiently fast and efficient. However, for extremely large numbers, more advanced and sophisticated methods are required that take advantage of deeper mathematical properties and that can be parallelized in distributed computing systems.

In addition to the comparison of algorithms, this thesis will also explore the practical implementation of these methods. Performance in a modern programming language will be evaluated. Experiments will be performed to measure the execution time and efficiency of the algorithms implemented in Python.
% The fundamental theorem of arithmetic states that every number can be expressed as a product of prime numbers or be a prime number. In mathematics and, more recently, in computer science, a problem of great importance is to find the set of prime numbers that, when multiplied, give us the original number.

% Although algorithms for this task have been known since ancient times, it is particularly relevant today because a large part of computer security is based on the difficulty of factoring very large numbers. Although efficient algorithms with polynomial complexity exist for this task, the enormous size of the numbers used in modern cryptography makes factorization still a considerable challenge.

% In this thesis, an analysis and comparison of various factorization algorithms and methods will be carried out to determine which are the most suitable according to the type of number and the context in which they must be used. In addition, the refinement of these methods during their implementation in a modern programming language will be addressed.\\
\textbf{Keywords:} Factorization, prime numbers, fundamental theorem of arithmetic, prime factors.\\
\textbf{Methodology:} Inductive logical method.
